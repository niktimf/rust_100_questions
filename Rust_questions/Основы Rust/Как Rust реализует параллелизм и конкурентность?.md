#Основы 

# Определения
<span style="color:crimson"><b>Конкурентность</b></span> - это способность программы управлять выполнением нескольких задач одновременно, даже если эти задачи не обязательно выполняются параллельно. Конкурентность позволяет эффективно использовать ресурсы системы, управляя переключением контекста между задачами. 
**Пример**: Повар может начать готовить суп, затем, пока суп варится, перейти к нарезке овощей для салата. Затем повар может перемешивать суп, пока он варится, и снова вернуться к нарезке овощей. Повар переключается между задачами, чтобы максимально использовать своё время. Важно, что задачи могут выполняться не одновременно, а последовательно, но повар управляет несколькими задачами в одно и то же время.

<span style="color:crimson"><b>Параллелизм</b></span> - это выполнение нескольких задач одновременно на разных процессорных ядрах. Параллелизм позволяет значительно ускорить выполнение задач, используя многопоточность или распределенные вычисления.
**Пример**: Теперь представьте, что у повара есть помощник. Повар готовит суп, а помощник одновременно нарезает овощи для салата. Оба процесса происходят одновременно, что позволяет приготовить еду быстрее. Здесь задачи действительно выполняются одновременно на разных "процессорных ядрах" (повар и помощник).


![[Pasted image 20240725114715.png]]

# Инструменты для реализации конкурентности и параллелизма

**Создание потоков**
```rust
use std::thread;

fn main() {
	let handle = thread::spawn(|| { 
		for i in 1..10 { 
			println!("Поток: {}", i); 
		} 
	});
	
	for i in 1..5 { 
		println!("Главный поток: {}", i); 
	} 
	
	handle.join().unwrap(); 
} 	
```

**Синхронизация данных**
```rust 
use std::sync::{Arc, Mutex}; 
use std::thread;

fn main() {
	let counter = Arc::new(Mutex::new(0));
	let mut handles = vec![];
	
	for _ in 0..10 { 
		let counter = Arc::clone(&counter); 
		let handle = thread::spawn(move || {
			let mut num = counter.lock().unwrap(); 
			*num += 1; 
		});
		handles.push(handle);
	}
	
	for handle in handles {
		handle.join().unwrap(); 
	}
	
	println!("Результат: {}", *counter.lock().unwrap()); 
}
```

**Асинхронное программирование**
```rust 
use tokio::time::{sleep, Duration}; 

#[tokio::main]
async fn main() {
	let task1 = tokio::spawn(async {
		sleep(Duration::from_secs(2)).await; 
		println!("Задача 1 выполнена"); 
	});
	
	let task2 = tokio::spawn(async {
		sleep(Duration::from_secs(1)).await;
		println!("Задача 2 выполнена");
	});
	
	task1.await.unwrap();
	task2.await.unwrap();
}
```